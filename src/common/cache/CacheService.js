const crypto = require('crypto');
const { CacheModes, kCACHE_DEFAULT_TTL } = require('./CacheConstants');
const utils = require('../../utils');

/**
 * Cache service implementing adapter pattern with multiple cache strategies.
 *
 * Supports multiple cache modes:
 * - DEFAULT: Normal cache behavior (read/write)
 * - SKIP: Bypass cache entirely
 * - BUST: Clear cache entry and fetch fresh data
 * - REFRESH: Update cache with fresh data
 *
 * Features:
 * - Entity rehydration (converts plain objects back to Entity instances)
 * - Consistent cache key generation with parameter sorting
 * - User-specific caching
 * - TTL support
 * - Prefix-based cache invalidation
 *
 * @class CacheService
 * @example
 * const cache = new CacheService(new NodeCacheAdapter());
 * const key = cache.getCacheKey('users:list', { page: 1, limit: 10 });
 */
class CacheService {
    /**
     * Creates an instance of CacheService.
     *
     * @param {Object} adapter - Cache adapter implementing get, set, del, and keys methods
     * @param {Function} adapter.get - Retrieve value by key
     * @param {Function} adapter.set - Store value with optional TTL
     * @param {Function} adapter.del - Delete one or more keys
     * @param {Function} adapter.keys - List all keys
     *
     * @throws {Error} If adapter is invalid or missing required methods
     *
     * @example
     * const cache = new CacheService(new NodeCacheAdapter());
     *
     * @example
     * // With custom Redis adapter
     * const cache = new CacheService(new RedisAdapter(redisClient));
     */
    constructor(adapter) {
        if (!adapter || typeof adapter.get !== 'function') {
            throw new Error('A valid cache adapter is required');
        }

        /**
         * The cache adapter instance.
         * @type {Object}
         * @private
         */
        this.adapter = adapter;
    }

    /**
     * Generates a consistent cache key from base key, parameters, and user ID.
     *
     * Keys are generated by:
     * 1. Sorting parameter keys alphabetically
     * 2. Serializing values (objects sorted by keys)
     * 3. Appending user ID if provided
     * 4. Hashing the combined string with MD5
     *
     * This ensures the same parameters always generate the same key,
     * regardless of parameter order.
     *
     * @param {string} baseKey - The base cache key (e.g., 'users:list', 'products:detail')
     * @param {Object} [params={}] - Query parameters or options
     * @param {number|string} [userId=null] - User ID for user-specific caching
     *
     * @returns {string} Hashed cache key in format 'baseKey:hash'
     *
     * @example
     * const key1 = cache.getCacheKey('icons', { page: 1, limit: 10 });
     * const key2 = cache.getCacheKey('icons', { limit: 10, page: 1 });
     * // key1 === key2 (order doesn't matter)
     *
     * @example
     * // User-specific caching
     * const key = cache.getCacheKey('favorites', { page: 1 }, userId);
     * // Returns: 'favorites:abc123def456...'
     *
     * @example
     * // With object parameters
     * const key = cache.getCacheKey('search', {
     *   filters: { category: 'icons', style: 'outline' },
     *   sort: 'name'
     * });
     */
    getCacheKey(baseKey, params = {}, userId = null) {
        const sortedKeys = Object.keys(params).sort();
        const keyParts = sortedKeys.map(key => {
            const val = params[key];
            const serialized = typeof val === 'object'
                ? JSON.stringify(val, Object.keys(val).sort())
                : String(val);
            return `${key}:${serialized}`;
        });

        if (userId) {
            keyParts.push(`userId:${userId}`);
        }

        const rawKey = `${baseKey}:${keyParts.join('|')}`;
        const hash = crypto.createHash('md5').update(rawKey).digest('hex');
        return `${baseKey}:${hash}`;
    }

    /**
     * Express/Fastify middleware for automatic request caching.
     *
     * Supports cache modes via query parameter `?cacheMode=skip|bust|refresh`:
     * - DEFAULT: Return cached data if available, otherwise fetch and cache
     * - SKIP: Bypass cache, always fetch fresh data
     * - BUST: Clear cache entry, fetch fresh data, don't re-cache
     * - REFRESH: Clear cache entry, fetch fresh data, cache the result
     *
     * The middleware automatically:
     * - Generates cache keys from request parameters
     * - Includes user ID in cache key if authenticated
     * - Adds `fromCache: true/false` to response
     * - Handles errors with next()
     *
     * @param {string} baseKey - Base cache key for this route
     * @param {Function} handler - Async function that returns data: `async (req) => data`
     * @param {number} [ttl=kCACHE_DEFAULT_TTL] - Time-to-live in seconds
     *
     * @returns {Function} Express/Fastify middleware function
     *
     * @example
     * // Basic usage
     * app.get('/api/icons',
     *   cache.cacheHandler('icons:list', async (req) => {
     *     return iconService.getAll(req.query);
     *   }, 3600)
     * );
     *
     * @example
     * // Client can control cache behavior:
     * // GET /api/icons?cacheMode=skip    - Always fresh
     * // GET /api/icons?cacheMode=bust    - Clear and fetch
     * // GET /api/icons?cacheMode=refresh - Update cache
     *
     * @example
     * // With authentication
     * app.get('/api/favorites',
     *   authenticate,
     *   cache.cacheHandler('favorites', async (req) => {
     *     return favoriteService.getUserFavorites(req.user.id);
     *   })
     * );
     * // Cache key includes user.id automatically
     */
    cacheHandler(baseKey, handler, ttl = kCACHE_DEFAULT_TTL) {
        return async (req, res, next) => {
            try {
                const params = utils.getRequestVars(req);
                const userId = req?.user?.id;
                const fullKey = this.getCacheKey(baseKey, params, userId);
                const mode = (req.query.cacheMode || CacheModes.DEFAULT).toLowerCase();

                const formatResult = (data, fromCache) => {
                    if (typeof data === 'object' && data !== null) {
                        return { ...data, fromCache };
                    }
                    return { data, fromCache };
                };

                const getMode = (value) => {
                    return Object.values(CacheModes).includes(value)
                        ? value
                        : CacheModes.DEFAULT;
                };

                switch (getMode(mode)) {
                    case CacheModes.SKIP:
                        return res.status(200).json(formatResult(await handler(req), false));

                    case CacheModes.BUST:
                        await this.adapter.del(fullKey);
                        return res.status(200).json(formatResult(await handler(req), false));

                    case CacheModes.REFRESH:
                        await this.adapter.del(fullKey);
                        const refreshed = await handler(req);
                        await this.adapter.set(fullKey, refreshed, ttl);
                        return res.status(200).json(formatResult(refreshed, false));

                    default:
                        const cached = await this.adapter.get(fullKey);
                        if (cached) {
                            return res.status(200).json(formatResult(cached, true));
                        }
                        const result = await handler(req);
                        await this.adapter.set(fullKey, result, ttl);
                        return res.status(200).json(formatResult(result, false));
                }
            }
            catch (err) {
                next(err);
            }
        };
    }

    /**
     * Clears cache entries by base key prefix or custom matcher function.
     *
     * Useful for cache invalidation when data changes:
     * - Clear all keys with a specific prefix
     * - Clear keys matching custom criteria
     * - Clear all keys (no parameters)
     *
     * @async
     * @param {Object} [options={}] - Clearing options
     * @param {string} [options.baseKey] - Clear all keys starting with this prefix
     * @param {Function} [options.matcher] - Custom function to filter keys: `(key) => boolean`
     *
     * @returns {Promise<number>} Number of keys cleared
     *
     * @example
     * // Clear all icon-related cache entries
     * await cache.clearCache({ baseKey: 'icons' });
     * // Clears: icons:list, icons:detail:*, etc.
     *
     * @example
     * // Clear with custom matcher
     * await cache.clearCache({
     *   matcher: (key) => key.includes('user:123')
     * });
     *
     * @example
     * // Clear all cache entries
     * await cache.clearCache();
     *
     * @example
     * // Clear after data update
     * await iconService.updateIcon(id, data);
     * await cache.clearCache({ baseKey: 'icons' });
     */
    async clearCache({ baseKey, matcher } = {}) {
        const keys = await this.adapter.keys();
        let matched = keys;

        if (typeof matcher === 'function') {
            matched = keys.filter(matcher);
        }
        else if (baseKey) {
            matched = keys.filter(k => k.startsWith(`${baseKey}:`));
        }

        await this.adapter.del(matched);
        console.log(`[CacheService] Cleared ${matched.length} key(s)`, matched);
        return matched.length;
    }
}

module.exports = CacheService;
